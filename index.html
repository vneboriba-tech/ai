<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Почувствуй себя журналистом</title>
  <meta name="description" content="Журналист / Блогер / Фотограф — фон и образ под позу, с сохранением лица и рук" />
  <style>
    :root { --bg:#ffffff; --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --accent:#2563eb; }
    * { box-sizing:border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Avenir Next",Segoe UI,Roboto,Helvetica,Arial;}
    body { display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { text-align:center; margin-top:24px; margin-bottom:16px; }
    h1 { font-size:clamp(28px,4vw,42px); margin:0; font-weight:800; }
    .container { width:100%; max-width:960px; padding:20px; }
    .uploader { border:2px dashed var(--border); border-radius:24px; padding:40px 20px; background:#f9fafb; text-align:center; cursor:pointer; transition:.2s; }
    .uploader:hover { border-color:var(--accent); background:#f0f9ff; }
    .uploader img.logo { width:72px; height:72px; margin-bottom:12px; }
    .headline { font-weight:700; font-size:18px; }
    .sub { color:var(--muted); font-size:14px; margin-top:6px; }
    .picked { margin-top:10px; font-size:14px; }
    .roles { margin-top:24px; }
    .roles-title { text-align:center; font-weight:700; font-size:18px; }
    .roles-grid { display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px; }
    @media(min-width:720px){ .roles-grid{grid-template-columns:repeat(3,1fr);} }
    .role { border:1px solid var(--border); border-radius:14px; padding:12px; font-weight:700; cursor:pointer; background:#fff; transition:.15s; }
    .role:hover { box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .role.active { border-color:var(--accent); box-shadow:0 0 0 3px rgba(37,99,235,0.2); }
    .status { margin-top:20px; text-align:center; font-size:15px; white-space:pre-wrap; }
    .err { color:#dc2626; font-size:14px; text-align:center; margin-top:10px; display:none; white-space:pre-wrap; }
    .result { margin-top:24px; text-align:center; }
    .result img { width:100%; max-width:800px; border-radius:18px; border:1px solid var(--border); }
    .btn { background:#10b981; color:#fff; padding:10px 16px; border-radius:12px; border:none; cursor:pointer; font-weight:700; }
    .btn:hover { background:#059669; }
    footer { margin-top:40px; text-align:center; color:#6b7280; font-size:14px; }
    pre#logs { text-align:left; background:#0b1020; color:#cbd5e1; padding:12px; border-radius:12px; overflow:auto; max-height:260px; font-size:12px; display:none; }
  </style>

  <!-- TF.js + BodyPix + Pose (MoveNet) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.16.0/dist/tf-backend-webgl.min.js"></script>
</head>
<body>
  <div class="container">
    <header><h1>Почувствуй себя журналистом</h1></header>

    <div class="uploader" id="dropzone">
      <img src="logo.png" alt="Логотип" class="logo" onerror="this.style.display='none'">
      <div class="headline">Загрузите фото</div>
      <div class="sub">JPG, PNG, WEBP до 12 МБ</div>
      <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp" style="display:none" />
      <div id="picked" class="picked"></div>
    </div>

    <div class="roles">
      <div class="roles-title">Выберите роль</div>
      <div class="roles-grid">
        <button class="role active" data-role="журналист">Журналист</button>
        <button class="role" data-role="блогер">Блогер</button>
        <button class="role" data-role="фотограф">Фотограф</button>
      </div>
    </div>

    <div id="status" class="status">Готово к работе</div>
    <div id="error" class="err"></div>

    <div id="resultBox" class="result" style="display:none;">
      <img id="resultImg" alt="Результат">
      <div style="margin-top:12px;">
        <a id="download" class="btn" download="result.png" style="display:none;">Скачать PNG</a>
      </div>
    </div>

    <pre id="logs"></pre>
  </div>

  <footer>© 2025 факультет журналистики МГУ</footer>

<script>
const API_BASE = "https://media-gen-worker.vneboriba.workers.dev";
const MAX_MB = 12;
const MAX_SIZE = 1024;

let file=null, role="журналист";
let bp=null, poseModel=null;

const CLOTH_STRENGTH = 0.45;
const BG_STEPS = 20;

const input = document.getElementById("fileInput");
const drop  = document.getElementById("dropzone");
const picked= document.getElementById("picked");
const statusEl=document.getElementById("status");
const errEl=document.getElementById("error");
const resultBox=document.getElementById("resultBox");
const resultImg=document.getElementById("resultImg");
const download=document.getElementById("download");
const logsEl=document.getElementById("logs");

function showErr(m){ errEl.style.display="block"; errEl.innerText=m; statusEl.innerText="Ошибка"; }
function hideErr(){ errEl.style.display="none"; errEl.innerText=""; }
function log(o){ try{ logsEl.style.display="block"; logsEl.textContent=typeof o==="string"?o:JSON.stringify(o,null,2);}catch{} }
function fetchTO(url, init={}, ms=120000){ const c=new AbortController(); const id=setTimeout(()=>c.abort(),ms); return fetch(url,{...init,signal:c.signal}).finally(()=>clearTimeout(id)); }

drop.addEventListener("click",()=>input.click());
drop.addEventListener("dragover",e=>e.preventDefault());
drop.addEventListener("drop",e=>{e.preventDefault();const f=e.dataTransfer.files?.[0];if(f)handleFile(f);});
input.addEventListener("change",e=>handleFile(e.target.files?.[0]));

document.querySelectorAll(".role").forEach(b=>{
  b.addEventListener("click",()=>{
    document.querySelectorAll(".role").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    role=b.dataset.role;
    if (file) generate();
  });
});

async function loadBP(){ if (bp) return bp; statusEl.innerText="Загрузка сегментации…"; bp = await bodyPix.load({architecture:"MobileNetV1", outputStride:16, multiplier:0.75, quantBytes:2}); return bp; }
async function loadPose(){
  if (poseModel) return poseModel;
  statusEl.innerText="Загрузка позы…";
  const m = poseDetection.SupportedModels.MoveNet;
  poseModel = await poseDetection.createDetector(m, { modelType: 'SinglePose.Lightning' });
  return poseModel;
}

function loadImg(src){ return new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin="anonymous"; i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }

function handleFile(f){
  if (!f) return;
  if (!f.type.startsWith("image/")) return showErr("Нужен файл изображения.");
  if (f.size>MAX_MB*1024*1024) return showErr("Слишком большой файл (до 12 МБ).");
  hideErr(); file=f; picked.innerText=`Вы выбрали: ${f.name}`; generate();
}

async function resizeFile(f){
  const du=await new Promise((res,rej)=>{const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f);});
  const im=await loadImg(du); let w=im.width,h=im.height,k=Math.max(w,h)>MAX_SIZE?MAX_SIZE/Math.max(w,h):1;
  w=Math.round(w*k); h=Math.round(h*k);
  const c=document.createElement("canvas"); c.width=w; c.height=h; c.getContext("2d").drawImage(im,0,0,w,h);
  const out=c.toDataURL("image/jpeg",0.92);
  return {w,h, dataUrl:out, b64:out.split(",")[1]};
}

/* ======= утилиты масок/кропов/цвета ======= */
function binarizeAlpha(canvas, thr=128){
  const w=canvas.width, h=canvas.height;
  const g=canvas.getContext("2d");
  const id=g.getImageData(0,0,w,h);
  for(let i=0;i<id.data.length;i+=4){
    const a=id.data[i+3]; const v=a>=thr?255:0;
    id.data[i]=id.data[i+1]=id.data[i+2]=0; id.data[i+3]=v;
  }
  g.putImageData(id,0,0); return canvas;
}
// morph = blur + threshold (эрозия/дилатация по альфе)
function morph(maskCanvas, blurPx = 4, thr = 128) {
  const w = maskCanvas.width, h = maskCanvas.height;
  const c = document.createElement("canvas"); c.width = w; c.height = h;
  const g = c.getContext("2d");
  g.filter = `blur(${blurPx}px)`;
  g.drawImage(maskCanvas, 0, 0);
  return binarizeAlpha(c, thr);
}
function closeMask(canvas, blurPx=8, thr=64){
  const w=canvas.width,h=canvas.height;
  const b=document.createElement("canvas"); b.width=w;b.height=h;
  const gb=b.getContext("2d"); gb.filter=`blur(${blurPx}px)`; gb.drawImage(canvas,0,0);
  return binarizeAlpha(b, thr);
}
function poseHullMask(w,h,keypoints){
  const pts=keypoints.filter(k=>k.score>0.3).map(k=>({x:k.x,y:k.y}));
  const c=document.createElement("canvas"); c.width=w;c.height=h; const g=c.getContext("2d");
  if (pts.length<3) return c;
  pts.sort((a,b)=>a.x-b.x||a.y-b.y);
  const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower=[],upper=[];
  for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop();
  const hull=[...lower,...upper];
  g.fillStyle="#fff"; g.beginPath(); g.moveTo(hull[0].x,hull[0].y); for(const p of hull) g.lineTo(p.x,p.y); g.closePath(); g.fill();
  const d=document.createElement("canvas"); d.width=w; d.height=h; const gd=d.getContext("2d"); gd.filter="blur(10px)"; gd.drawImage(c,0,0); return d;
}
function cropSquareAroundBBox(img, bbox, padK=0.22, outSize=512){
  const w=img.width, h=img.height;
  const side = Math.min(Math.max(bbox.w, bbox.h)*(1+padK), Math.min(w,h));
  const cx = bbox.x + bbox.w/2, cy = bbox.y + bbox.h/2;
  const x = Math.max(0, Math.min(w-side, cx - side/2));
  const y = Math.max(0, Math.min(h-side, cy - side/2));
  const c=document.createElement("canvas"); c.width=outSize; c.height=outSize;
  const g=c.getContext("2d"); g.drawImage(img, x,y,side,side, 0,0,outSize,outSize);
  return { dataUrl: c.toDataURL("image/png"), rect:{x,y,side} };
}
function dilateFeatherMaskDataUrl(maskDataUrl, radius=10, blur=12){
  return new Promise(async (res)=>{
    const maskImg = await loadImg(maskDataUrl);
    const w=maskImg.width, h=maskImg.height;
    const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
    g.drawImage(maskImg,0,0);
    const d=document.createElement("canvas"); d.width=w; d.height=h; const gd=d.getContext("2d");
    gd.filter=`blur(${radius}px)`; gd.drawImage(c,0,0);
    const out=document.createElement("canvas"); out.width=w; out.height=h; const go=out.getContext("2d");
    go.filter=`blur(${blur}px)`; go.drawImage(d,0,0);
    res(out.toDataURL("image/png"));
  });
}
function statsRGB(canvas, rect){
  const {x,y,w,h} = rect;
  const g=canvas.getContext("2d");
  const id=g.getImageData(Math.max(0,x|0), Math.max(0,y|0), Math.max(1,w|0), Math.max(1,h|0));
  const n=id.data.length/4;
  let mr=0,mg=0,mb=0; for(let i=0;i<id.data.length;i+=4){ mr+=id.data[i]; mg+=id.data[i+1]; mb+=id.data[i+2]; }
  mr/=n; mg/=n; mb/=n;
  let vr=0,vg=0,vb=0; for(let i=0;i<id.data.length;i+=4){ vr+=(id.data[i]-mr)**2; vg+=(id.data[i+1]-mg)**2; vb+=(id.data[i+2]-mb)**2; }
  vr=Math.sqrt(vr/n); vg=Math.sqrt(vg/n); vb=Math.sqrt(vb/n);
  return {mean:[mr,mg,mb], std:[vr,vg,vb]};
}
function matchColors(srcCanvas, targetStats){
  const w=srcCanvas.width, h=srcCanvas.height;
  const g=srcCanvas.getContext("2d");
  const id=g.getImageData(0,0,w,h);
  const s=statsRGB(srcCanvas,{x:0,y:0,w,h});
  const out=id.data;
  for(let i=0;i<out.length;i+=4){
    for(let c=0;c<3;c++){
      const ch=out[i+c];
      const z = s.std[c]>1 ? (ch - s.mean[c]) / s.std[c] : 0;
      const m = z * (targetStats.std[c]||1) + (targetStats.mean[c]||0);
      out[i+c] = Math.max(0, Math.min(255, m));
    }
  }
  g.putImageData(id,0,0);
  return srcCanvas;
}
/* ============================================ */

/* матты + bbox */
async function buildMattesAndBBox(dataUrl){
  await Promise.all([loadBP(), loadPose()]);
  const img=await loadImg(dataUrl); const w=img.width,h=img.height;

  const [person, parts, poses] = await Promise.all([
    bp.segmentPerson(img,{internalResolution:'medium',segmentationThreshold:0.7}),
    bp.segmentPersonParts(img,{internalResolution:'medium',segmentationThreshold:0.7}),
    poseModel.estimatePoses(img)
  ]);

  let minX=w, minY=h, maxX=0, maxY=0;
  const kp=(poses[0]?.keypoints||[]).filter(k=>k.score>0.3);
  for (const p of kp){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
  if (!isFinite(minX)||!kp.length){ minX=w*0.25; maxX=w*0.75; minY=h*0.1; maxY=h*0.95; }
  const padX=(maxX-minX)*0.18, padY=(maxY-minY)*0.10;
  minX=Math.max(0,minX-padX); maxX=Math.min(w,maxX+padX);
  minY=Math.max(0,minY-padY); maxY=Math.min(h,maxY+padY);
  const bbox={ x:minX, y:minY, w:(maxX-minX), h:(maxY-minY) };

  const HEAD=new Set([0,1]); const ARMS=new Set([2,3,4,5]);

  // base mask
  const baseMask=document.createElement("canvas"); baseMask.width=w; baseMask.height=h;
  {
    const g=baseMask.getContext("2d");
    const id=g.createImageData(w,h);
    for(let i=0;i<w*h;i++) id.data[i*4+3]=(person.data[i]===1)?255:0;
    g.putImageData(id,0,0);
  }
  const hull = poseHullMask(w,h,kp);
  const union=document.createElement("canvas"); union.width=w; union.height=h;
  { const g=union.getContext("2d"); g.drawImage(baseMask,0,0); g.globalCompositeOperation="lighter"; g.drawImage(hull,0,0); g.globalCompositeOperation="source-over"; }
  const closed = closeMask(union, 8, 32);
  const closedDilated = closeMask(closed, 4, 8);
  const mattePersonCanvas=document.createElement("canvas"); mattePersonCanvas.width=w; mattePersonCanvas.height=h;
  mattePersonCanvas.getContext("2d").drawImage(closedDilated,0,0);

  // head+hands
  const hhMask=document.createElement("canvas"); hhMask.width=w; hhMask.height=h;
  {
    const g=hhMask.getContext("2d"); const id=g.createImageData(w,h);
    for(let i=0;i<w*h;i++){ const pid=parts.data[i]; const on = (HEAD.has(pid)||ARMS.has(pid))?255:0; id.data[i*4+3]=on; }
    g.putImageData(id,0,0);
    const b=document.createElement("canvas"); b.width=w;b.height=h; const gb=b.getContext("2d"); gb.filter="blur(6px)"; gb.drawImage(hhMask,0,0);
    hhMask.width=w; hhMask.height=h; hhMask.getContext("2d").drawImage(b,0,0);

    // ШЕЙНЫЙ МОСТИК — тонкая вставка для непрерывности лица->шея
    const nx = Math.round(bbox.x + bbox.w * 0.48);
    const ny = Math.round(bbox.y + bbox.h * 0.35);
    const nw = Math.round(bbox.w * 0.04);
    const nh = Math.round(bbox.h * 0.10);
    const g2 = hhMask.getContext("2d");
    g2.fillStyle = "rgba(255,255,255,0.95)";
    g2.fillRect(nx, ny, nw, nh);
  }

  const base=await loadImg(dataUrl);
  const headCanvas=document.createElement("canvas"); headCanvas.width=w; headCanvas.height=h;
  const gh=headCanvas.getContext("2d"); gh.drawImage(base,0,0,w,h);
  gh.globalCompositeOperation="destination-in"; gh.drawImage(hhMask,0,0); gh.globalCompositeOperation="source-over";
  const headHands_png_b64=headCanvas.toDataURL("image/png").split(",")[1];

  const bodyMaskCanvas=document.createElement("canvas"); bodyMaskCanvas.width=w; bodyMaskCanvas.height=h;
  {
    const g=bodyMaskCanvas.getContext("2d"); g.drawImage(mattePersonCanvas,0,0);
    g.globalCompositeOperation="destination-out"; g.drawImage(hhMask,0,0); g.globalCompositeOperation="source-over";
    const b=document.createElement("canvas"); b.width=w;b.height=h; const gb=b.getContext("2d"); gb.filter="blur(5px)"; gb.drawImage(bodyMaskCanvas,0,0);
    bodyMaskCanvas.width=w; bodyMaskCanvas.height=h; bodyMaskCanvas.getContext("2d").drawImage(b,0,0);
  }

  // широкая «резервная» маска под человека
  const reserve=document.createElement("canvas"); reserve.width=w; reserve.height=h; const gr=reserve.getContext("2d");
  gr.fillStyle="#000"; gr.fillRect(0,0,w,h); gr.fillStyle="#fff";
  const r=Math.max(bbox.w,bbox.h)*0.16;
  gr.beginPath(); gr.moveTo(bbox.x+r,bbox.y);
  gr.arcTo(bbox.x+bbox.w,bbox.y,bbox.x+bbox.w,bbox.y+bbox.h,r);
  gr.arcTo(bbox.x+bbox.w,bbox.y+bbox.h,bbox.x,bbox.y+bbox.h,r);
  gr.arcTo(bbox.x,bbox.y+bbox.h,bbox.x,bbox.y,r);
  gr.arcTo(bbox.x,bbox.y,bbox.x+bbox.w,bbox.y,r); gr.closePath(); gr.fill();
  const reserveFeather=document.createElement("canvas"); reserveFeather.width=w; reserveFeather.height=h;
  const grf=reserveFeather.getContext("2d"); grf.filter="blur(10px)"; grf.drawImage(reserve,0,0);

  return {
    mattePerson_b64: mattePersonCanvas.toDataURL("image/png").split(",")[1],
    headHands_png_b64,
    bodyOnly_mask_b64: bodyMaskCanvas.toDataURL("image/png").split(",")[1],
    reserve_mask_b64: reserveFeather.toDataURL("image/png").split(",")[1],
    bbox
  };
}

/* ===== Prompts (реалистичные) ===== */
function bgPrompt(role){
  if (role==="журналист")
    return "broadcast newsroom, glass anchor desk, cameras and boom mics, LED video wall with abstract news graphics, ceiling light panels with soft falloff, subtle floor reflections, shallow depth of field, photographic noise, correct perspective lines; photorealistic; no readable text";
  if (role==="блогер")
    return "creator studio, ring light, softboxes, green screen, tripod camera, cozy décor, shelves with props, shallow depth of field, photographic noise, correct perspective; photorealistic; no readable text";
  if (role==="фотограф")
    return "professional photo studio, backdrop rolls, C-stands, light stands, softboxes, cables, realistic shadows, slight lens falloff, photographic noise, correct perspective; photorealistic; no readable text";
  return "neutral professional studio background, photographic noise, realistic lighting; no text";
}
function outfitPrompt(role){
  if (role==="журналист") return "update ONLY clothing to smart-casual journalist style: tailored blazer in neutral tones, optional lapel mic; keep the same person and identity; photorealistic";
  if (role==="блогер")    return "update ONLY clothing to stylish casual blogger style: light hoodie or tee, relaxed trousers; keep the same person and identity; photorealistic";
  if (role==="фотограф")  return "update ONLY clothing to practical photographer style: dark utility vest or jacket; keep the same person and identity; photorealistic";
  return "subtle outfit update; keep identity";
}

async function addContactShadow(baseUrl, bbox){
  const img=await loadImg(baseUrl);
  const c=document.createElement("canvas"); c.width=img.width; c.height=img.height;
  const g=c.getContext("2d"); g.drawImage(img,0,0);
  const cx=(bbox.x + bbox.w*0.5), cy=(bbox.y + bbox.h*0.98);
  const rx=bbox.w*0.45, ry=bbox.h*0.06;
  g.save(); g.filter="blur(6px)"; g.globalAlpha=0.28;
  g.beginPath(); g.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); g.fillStyle="#000"; g.fill();
  g.restore();
  return c.toDataURL("image/png");
}
async function composeLogoOver(imgDataUrl){
  const base = await loadImg(imgDataUrl);
  const logo = await loadImg("logo.png").catch(()=>null);
  if (!logo) return imgDataUrl;
  const w=base.width,h=base.height;
  const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
  g.drawImage(base,0,0,w,h);
  const logoW=Math.max(120,Math.round(w*0.16)); const scale=logoW/logo.width; const logoH=Math.round(logo.height*scale);
  const pad=Math.max(16,Math.round(Math.min(w,h)*0.02)); const x=w-logoW-pad; const y=h-logoH-pad;
  g.fillStyle="rgba(255,255,255,0.85)"; const br=Math.round(logoH*0.18);
  g.beginPath(); g.moveTo(x+br,y); g.arcTo(x+logoW,y,x+logoW,y+logoH,br); g.arcTo(x+logoW,y+logoH,x,y+logoH,br); g.arcTo(x,y+logoH,x,y,br); g.arcTo(x,y,x+logoW,y,br); g.closePath(); g.fill();
  g.drawImage(logo,x,y,logoW,logoH);
  return c.toDataURL("image/png");
}

async function generate(){
  if (!file) return;
  statusEl.innerText="Подготовка…"; resultBox.style.display="none"; download.style.display="none"; hideErr(); logsEl.style.display="none";

  try{
    let {w,h,dataUrl,b64} = await resizeFile(file);

    statusEl.innerText="Шаг 1/6: анализ позы и сегментация…";
    const mats = await buildMattesAndBBox(dataUrl);

    statusEl.innerText="Шаг 2/6: генерация фона…";
    let fd=new FormData();
    fd.append("mode","gen-bg"); fd.append("width", String(w)); fd.append("height", String(h));
    fd.append("num_steps", String(BG_STEPS)); fd.append("prompt", bgPrompt(role));
    let r=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fd }, 120000);
    let j=JSON.parse(await r.text());
    if (!r.ok || !j.imageBase64) return showErr(j?.error||"Не удалось создать фон");
    let bgUrl="data:image/png;base64,"+j.imageBase64;

    statusEl.innerText="Шаг 3/6: подчистка фона под человека…";
    fd=new FormData();
    fd.append("mode","bg-inpaint");
    fd.append("image_b64", bgUrl.split(",")[1]);
    fd.append("mask_b64", mats.reserve_mask_b64);
    fd.append("prompt", "keep background consistent and clean space for a standing person; photorealistic; no text");
    r=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fd }, 120000);
    j=JSON.parse(await r.text());
    if (r.ok && j.imageBase64) bgUrl = "data:image/png;base64,"+j.imageBase64;

    statusEl.innerText="Шаг 4/6: построение манекена…";
    const fullImg = await loadImg(dataUrl);
    const crop = cropSquareAroundBBox(fullImg, mats.bbox, 0.22, 512);
    const silhouette = document.createElement("canvas"); silhouette.width=512; silhouette.height=512;
    {
      const g=silhouette.getContext("2d");
      const src=await loadImg(crop.dataUrl); g.drawImage(src,0,0,512,512);
      const matte=await loadImg("data:image/png;base64,"+mats.mattePerson_b64);
      const matteCrop = cropSquareAroundBBox(matte, mats.bbox, 0.22, 512);
      const mImg=await loadImg(matteCrop.dataUrl);
      g.globalAlpha=0.65; g.drawImage(mImg,0,0);
    }
    let fdBP=new FormData();
    fdBP.append("mode","body-proxy");
    fdBP.append("image_b64", silhouette.toDataURL("image/png").split(",")[1]);
    fdBP.append("prompt",
      role==="журналист"
        ? "upper body of a professional journalist wearing a tailored blazer and microphone pin, realistic proportions, neutral colors"
        : role==="блогер"
        ? "upper body of a trendy blogger in casual outfit, hoodie or denim jacket, realistic proportions"
        : "upper body of a photographer in dark functional outfit, camera strap, realistic proportions"
    );
    let rBP=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fdBP }, 120000);
    let jBP=JSON.parse(await rBP.text());
    let bodyProxy512 = jBP?.imageBase64 ? "data:image/png;base64,"+jBP.imageBase64 : crop.dataUrl;

    statusEl.innerText="Шаг 5/6: смена одежды…";
    const bodyMaskFull = await loadImg("data:image/png;base64,"+mats.bodyOnly_mask_b64);
    const bodyMaskCrop512 = cropSquareAroundBBox(bodyMaskFull, mats.bbox, 0.22, 512);
    const dilatedMask512 = await dilateFeatherMaskDataUrl(bodyMaskCrop512.dataUrl, 10, 12);
    const fdW=new FormData();
    fdW.append("mode","wardrobe-mask");
    fdW.append("image_b64", bodyProxy512.split(",")[1]);
    fdW.append("mask_b64",  dilatedMask512.split(",")[1]);
    fdW.append("prompt", outfitPrompt(role));
    fdW.append("strength", String(CLOTH_STRENGTH));
    const rW=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fdW }, 120000);
    const jW=JSON.parse(await rW.text());
    const outfit512=jW?.imageBase64 ? "data:image/png;base64,"+jW.imageBase64 : bodyProxy512;

    // вклейка 512→в полный размер (новый источник тела)
    const fullC=document.createElement("canvas"); fullC.width=fullImg.width; fullC.height=fullImg.height;
    const gfull=fullC.getContext("2d"); gfull.drawImage(fullImg,0,0);
    const o512=await loadImg(outfit512); const {x,y,side}=crop.rect; gfull.drawImage(o512, x,y,side,side);
    dataUrl=fullC.toDataURL("image/png"); b64=dataUrl.split(",")[1];

    /* ===== Шаг 6/6: сборка сцены (r13d) ===== */
    const bg = await loadImg(bgUrl);
    const body = await loadImg(dataUrl);
    const matteP = await loadImg("data:image/png;base64,"+mats.mattePerson_b64);
    const headH = await loadImg("data:image/png;base64,"+mats.headHands_png_b64);

    const comp = document.createElement("canvas"); comp.width = bg.width; comp.height = bg.height;
    const g = comp.getContext("2d");

    // центрирование: двигаем ФОН (cover-масштаб, чтобы не было чёрных полей)
    const targetCX = bg.width/2;
    const srcCX = mats.bbox.x + mats.bbox.w/2;
    const dx = Math.round(targetCX - srcCX);
    const needPad = Math.abs(dx);
    const scale = 1 + (needPad*2)/bg.width + 0.04; // небольшой запас
    const sw = Math.round(bg.width * scale);
    const sh = Math.round(bg.height * scale);
    const ox = Math.round((sw - bg.width)/2) - dx;
    const oy = Math.round((sh - bg.height)/2);
    g.drawImage(bg, -ox, -oy, sw, sh);

    // маска: inner (резко) + edge (только край с пером)
    const matteCanvas = document.createElement("canvas");
    matteCanvas.width = bg.width; matteCanvas.height = bg.height;
    matteCanvas.getContext("2d").drawImage(matteP,0,0);
    const inner = morph(matteCanvas, 1.5, 150);
    const outer = morph(matteCanvas, 10, 10);
    const edge = document.createElement("canvas"); edge.width=bg.width; edge.height=bg.height;
    const ge = edge.getContext("2d");
    ge.drawImage(outer,0,0);
    ge.globalCompositeOperation="destination-out"; ge.drawImage(inner,0,0);
    ge.globalCompositeOperation="source-over"; ge.filter="blur(8px)"; ge.drawImage(edge,0,0);

    const softMask = document.createElement("canvas"); softMask.width=bg.width; softMask.height=bg.height;
    const gs = softMask.getContext("2d"); gs.drawImage(inner,0,0); gs.globalCompositeOperation="lighter"; gs.drawImage(edge,0,0);

    // тело: цвето-матч + локальная резкость ткани
    const bodyAdj = document.createElement("canvas"); bodyAdj.width=body.width; bodyAdj.height=body.height;
    bodyAdj.getContext("2d").drawImage(body,0,0);

    const bgStats = statsRGB(comp, {
      x: Math.max(0, mats.bbox.x - 20),
      y: Math.max(0, mats.bbox.y - 20),
      w: mats.bbox.w + 40,
      h: mats.bbox.h + 40
    });
    matchColors(bodyAdj, bgStats);

    // лёгкий unsharp без лица — применим до маски
    const sharp = document.createElement("canvas");
    sharp.width = bodyAdj.width; sharp.height = bodyAdj.height;
    const gsx = sharp.getContext("2d"); gsx.drawImage(bodyAdj,0,0);
    const blur = document.createElement("canvas");
    blur.width = bodyAdj.width; blur.height = bodyAdj.height;
    const gbx = blur.getContext("2d"); gbx.filter = "blur(2px)"; gbx.drawImage(bodyAdj,0,0);
    const idSrc = gsx.getImageData(0,0,sharp.width,sharp.height);
    const idBlur = gbx.getImageData(0,0,sharp.width,sharp.height);
    const d = idSrc.data, b = idBlur.data;
    for (let i=0;i<d.length;i+=4){
      d[i]   = Math.max(0, Math.min(255, d[i]*1.25 - b[i]*0.25));
      d[i+1] = Math.max(0, Math.min(255, d[i+1]*1.25 - b[i+1]*0.25));
      d[i+2] = Math.max(0, Math.min(255, d[i+2]*1.25 - b[i+2]*0.25));
    }
    gsx.putImageData(idSrc,0,0);
    bodyAdj.getContext("2d").drawImage(sharp,0,0);

    // лёгкая коррекция гаммы/контраста под фон
    const gAdj = bodyAdj.getContext("2d");
    const id = gAdj.getImageData(0,0,bodyAdj.width,bodyAdj.height);
    const p = id.data;
    for (let i=0;i<p.length;i+=4){
      for (let c=0;c<3;c++){
        let v = p[i+c]/255;
        v = Math.pow(v, 0.95);     // чуть светлее
        v = (v-0.5)*1.06 + 0.5;    // мягкий контраст
        p[i+c] = Math.max(0, Math.min(255, v*255));
      }
    }
    gAdj.putImageData(id,0,0);

    // применяем мягкую альфу
    const bodySoft = document.createElement("canvas"); bodySoft.width=bg.width; bodySoft.height=bg.height;
    const gb = bodySoft.getContext("2d"); gb.drawImage(bodyAdj,0,0);
    gb.globalCompositeOperation = "destination-in"; gb.drawImage(softMask,0,0); gb.globalCompositeOperation = "source-over";

    // корпус + голова/кисти поверх (без смещений)
    g.drawImage(bodySoft, 0, 0);
    g.drawImage(headH, 0, 0);

    let outUrl = comp.toDataURL("image/png");
    outUrl = await addContactShadow(outUrl, mats.bbox);
    outUrl = await composeLogoOver(outUrl);

    resultImg.src=outUrl; resultBox.style.display="block"; download.href=outUrl; download.style.display="inline-block";
    statusEl.innerText="Готово ✓ · шея непрерывная, край мягкий, фон покрывает кадр";
  }catch(e){
    showErr(e.message||"Неизвестная ошибка");
  }
}
</script>
</body>
</html>

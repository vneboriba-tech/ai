<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Почувствуй себя журналистом</title>
  <meta name="description" content="Журналист / Блогер / Фотограф — реалистичная смена окружения и образа при сохранении лица и рук" />
  <style>
    :root { --bg:#ffffff; --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --accent:#2563eb; }
    * { box-sizing:border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Avenir Next",Segoe UI,Roboto,Helvetica,Arial; }
    body { display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { text-align:center; margin-top:24px; margin-bottom:16px; }
    h1 { font-size:clamp(28px,4vw,42px); margin:0; font-weight:800; }
    .container { width:100%; max-width:960px; padding:20px; }
    .uploader { position:relative; border:2px dashed var(--border); border-radius:24px; padding:40px 20px; background:#f9fafb; text-align:center; cursor:pointer; transition:.2s; }
    .uploader:hover { border-color:var(--accent); background:#f0f9ff; }
    .uploader img.logo { width:72px; height:72px; margin-bottom:12px; pointer-events:none; }
    .uploader input[type=file]{ position:absolute; inset:0; width:100%; height:100%; opacity:0; cursor:pointer; display:block; }
    .headline { font-weight:700; font-size:18px; pointer-events:none; }
    .sub { color:var(--muted); font-size:14px; margin-top:6px; pointer-events:none; }
    .picked { margin-top:10px; font-size:14px; }
    .roles { margin-top:24px; }
    .roles-title { text-align:center; font-weight:700; font-size:18px; }
    .roles-grid { display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px; }
    @media(min-width:720px){ .roles-grid{grid-template-columns:repeat(3,1fr);} }
    .role { border:1px solid var(--border); border-radius:14px; padding:12px; font-weight:700; cursor:pointer; background:#fff; transition:.15s; }
    .role:hover { box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .role.active { border-color:var(--accent); box-shadow:0 0 0 3px rgba(37,99,235,0.2); }
    .status { margin-top:20px; text-align:center; font-size:15px; white-space:pre-wrap; }
    .err { color:#dc2626; font-size:14px; text-align:center; margin-top:10px; display:none; white-space:pre-wrap; }
    .result { margin-top:24px; text-align:center; }
    .result img { width:100%; max-width:800px; border-radius:18px; border:1px solid var(--border); }
    .btn { background:#10b981; color:#fff; padding:10px 16px; border-radius:12px; border:none; cursor:pointer; font-weight:700; }
    .btn:hover { background:#059669; }
    footer { margin-top:40px; text-align:center; color:#6b7280; font-size:14px; }
    pre#logs { text-align:left; background:#0b1020; color:#cbd5e1; padding:12px; border-radius:12px; overflow:auto; max-height:260px; font-size:12px; display:none; }
  </style>

  <!-- TF.js + BodyPix + Pose (MoveNet) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.16.0/dist/tf-backend-webgl.min.js"></script>
</head>
<body>
  <div class="container">
    <header><h1>Почувствуй себя журналистом</h1></header>

    <div class="uploader" id="dropzone">
      <img src="logo.png" alt="Логотип" class="logo" onerror="this.style.display='none'">
      <div class="headline">Загрузите фото</div>
      <div class="sub">JPG, PNG, WEBP до 12 МБ</div>
      <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp" />
      <div id="picked" class="picked"></div>
    </div>

    <div class="roles">
      <div class="roles-title">Выберите роль</div>
      <div class="roles-grid">
        <button class="role active" data-role="журналист">Журналист</button>
        <button class="role" data-role="блогер">Блогер</button>
        <button class="role" data-role="фотограф">Фотограф</button>
      </div>
    </div>

    <div id="status" class="status">Готово к работе</div>
    <div id="error" class="err"></div>

    <div id="resultBox" class="result" style="display:none;">
      <img id="resultImg" alt="Результат">
      <div style="margin-top:12px;">
        <a id="download" class="btn" download="result.png" style="display:none;">Скачать PNG</a>
      </div>
    </div>

    <pre id="logs"></pre>
  </div>

  <footer>© 2025 факультет журналистики МГУ</footer>

<script>
/* ===== CONFIG ===== */
const API_BASE = "https://media-gen-worker.vneboriba.workers.dev";
const MAX_MB = 12;

// единый размер результата (вертикальный)
const CANVAS_W = 720;
const CANVAS_H = 1280;

const BG_STEPS = 16;
const CLOTH_STRENGTH = 0.65;
const SHOW_LOGS = true;
  
/* ===== STATE ===== */
let file=null, role="журналист";
let bp=null, poseModel=null;

/* ===== UI ===== */
const input = document.getElementById("fileInput");
const drop  = document.getElementById("dropzone");
const picked= document.getElementById("picked");
const statusEl=document.getElementById("status");
const errEl=document.getElementById("error");
const resultBox=document.getElementById("resultBox");
const resultImg=document.getElementById("resultImg");
const download=document.getElementById("download");
const logsEl=document.getElementById("logs");

function showErr(m){ errEl.style.display="block"; errEl.innerText=m; statusEl.innerText="Ошибка"; }
function hideErr(){ errEl.style.display="none"; errEl.innerText=""; }
function log(o){ if (!SHOW_LOGS) return; try{ logsEl.style.display="block"; logsEl.textContent=typeof o==="string"?o:JSON.stringify(o,null,2);}catch{} }
function fetchTO(url, init={}, ms=120000){ const c=new AbortController(); const id=setTimeout(()=>c.abort(),ms); return fetch(url,{...init,signal:c.signal}).finally(()=>clearTimeout(id)); }

/* upload */
drop.addEventListener("dragover",e=>e.preventDefault());
drop.addEventListener("drop",e=>{e.preventDefault();const f=e.dataTransfer.files?.[0];if(f)handleFile(f);});
input.addEventListener("change",e=>handleFile(e.target.files?.[0]));

/* roles */
document.querySelectorAll(".role").forEach(b=>{
  b.addEventListener("click",()=>{
    document.querySelectorAll(".role").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    role=b.dataset.role;
    if (file) generate();
  });
});

/* ===== Models ===== */
async function loadBP(){ if (bp) return bp; statusEl.innerText="Загрузка сегментации…"; bp = await bodyPix.load({architecture:"MobileNetV1", outputStride:16, multiplier:0.75, quantBytes:2}); return bp; }
async function loadPose(){
  if (poseModel) return poseModel;
  statusEl.innerText="Загрузка позы…";
  const m = poseDetection.SupportedModels.MoveNet;
  poseModel = await poseDetection.createDetector(m, { modelType: 'SinglePose.Lightning' });
  return poseModel;
}

/* ===== Utils ===== */
function loadImg(src){ return new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin="anonymous"; i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }

function handleFile(f){
  if (!f) return;
  if (!f.type.startsWith("image/")) return showErr("Нужен файл изображения.");
  if (f.size>MAX_MB*1024*1024) return showErr("Слишком большой файл (до 12 МБ).");
  hideErr(); file=f; picked.innerText=`Вы выбрали: ${f.name}`; generate();
}

async function resizeFile(f){
  // читаем файл в dataURL
  const du = await new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = rej;
    r.readAsDataURL(f);
  });

  const im = await loadImg(du);

  const srcW = im.width;
  const srcH = im.height;

  // делаем как background-size: cover в CANVAS_W x CANVAS_H
  const c = document.createElement("canvas");
  c.width = CANVAS_W;
  c.height = CANVAS_H;
  const g = c.getContext("2d");

  const scale = Math.max(CANVAS_W / srcW, CANVAS_H / srcH);
  const newW = srcW * scale;
  const newH = srcH * scale;
  const dx = (CANVAS_W - newW) / 2;
  const dy = (CANVAS_H - newH) / 2;

  g.drawImage(im, dx, dy, newW, newH);

  const out = c.toDataURL("image/jpeg", 0.92);

  // ВАЖНО: возвращаем ещё параметры трансформации
  return {
    w: CANVAS_W,
    h: CANVAS_H,
    dataUrl: out,
    b64: out.split(",")[1],
    scale,
    dx,
    dy,
    srcW,
    srcH
  };
}
/* ===== Mask/Color helpers ===== */
function binarizeAlpha(canvas, thr=128){
  const w=canvas.width, h=canvas.height, g=canvas.getContext("2d"), id=g.getImageData(0,0,w,h);
  for(let i=0;i<id.data.length;i+=4){ const a=id.data[i+3]; const v=a>=thr?255:0; id.data[i]=id.data[i+1]=id.data[i+2]=0; id.data[i+3]=v; }
  g.putImageData(id,0,0); return canvas;
}
function morph(maskCanvas, blurPx = 4, thr = 128) {
  const w = maskCanvas.width, h = maskCanvas.height;
  const c = document.createElement("canvas"); c.width = w; c.height = h;
  const g = c.getContext("2d"); g.filter = `blur(${blurPx}px)`; g.drawImage(maskCanvas, 0, 0);
  return binarizeAlpha(c, thr);
}
function closeMask(canvas, blurPx=8, thr=64){
  const w=canvas.width,h=canvas.height;
  const b=document.createElement("canvas"); b.width=w;b.height=h;
  const gb=b.getContext("2d"); gb.filter=`blur(${blurPx}px)`; gb.drawImage(canvas,0,0);
  return binarizeAlpha(b, thr);
}
function poseHullMask(w,h,keypoints){
  const pts=keypoints.filter(k=>k.score>0.3).map(k=>({x:k.x,y:k.y}));
  const c=document.createElement("canvas"); c.width=w;c.height=h; const g=c.getContext("2d");
  if (pts.length<3) return c;
  pts.sort((a,b)=>a.x-b.x||a.y-b.y);
  const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower=[],upper=[];
  for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop();
  const hull=[...lower,...upper];
  g.fillStyle="#fff"; g.beginPath(); g.moveTo(hull[0].x,hull[0].y); for(const p of hull) g.lineTo(p.x,p.y); g.closePath(); g.fill();
  const d=document.createElement("canvas"); d.width=w; d.height=h; const gd=d.getContext("2d"); gd.filter="blur(10px)"; gd.drawImage(c,0,0); return d;
}
function cropSquareAroundBBox(img, bbox, padK=0.22, outSize=512){
  const w=img.width, h=img.height;
  const side = Math.min(Math.max(bbox.w, bbox.h)*(1+padK), Math.min(w,h));
  const cx = bbox.x + bbox.w/2, cy = bbox.y + bbox.h/2;
  const x = Math.max(0, Math.min(w-side, cx - side/2));
  const y = Math.max(0, Math.min(h-side, cy - side/2));
  const c=document.createElement("canvas"); c.width=outSize; c.height=outSize;
  const g=c.getContext("2d"); g.drawImage(img, x,y,side,side, 0,0,outSize,outSize);
  return { dataUrl: c.toDataURL("image/png"), rect:{x,y,side} };
}
function statsRGB(canvas, rect){
  const {x,y,w,h} = rect, g=canvas.getContext("2d");
  const id=g.getImageData(Math.max(0,x|0), Math.max(0,y|0), Math.max(1,w|0), Math.max(1,h|0));
  const n=id.data.length/4;
  let mr=0,mg=0,mb=0; for(let i=0;i<id.data.length;i+=4){ mr+=id.data[i]; mg+=id.data[i+1]; mb+=id.data[i+2]; }
  mr/=n; mg/=n; mb/=n;
  let vr=0,vg=0,vb=0; for(let i=0;i<id.data.length;i+=4){ vr+=(id.data[i]-mr)**2; vg+=(id.data[i+1]-mg)**2; vb+=(id.data[i+2]-mb)**2; }
  vr=Math.sqrt(vr/n); vg=Math.sqrt(vr/n); vb=Math.sqrt(vr/n);
  return {mean:[mr,mg,mb], std:[vr,vg,vb]};
}
function matchColors(srcCanvas, targetStats){
  const w=srcCanvas.width, h=srcCanvas.height, g=srcCanvas.getContext("2d"), id=g.getImageData(0,0,w,h), s=statsRGB(srcCanvas,{x:0,y:0,w,h});
  const out=id.data;
  for(let i=0;i<out.length;i+=4){
    for(let c=0;c<3;c++){
      const ch=out[i+c];
      const z = s.std[c]>1 ? (ch - s.mean[c]) / s.std[c] : 0;
      const m = z * (targetStats.std[c]||1) + (targetStats.mean[c]||0);
      out[i+c] = Math.max(0, Math.min(255, m));
    }
  }
  g.putImageData(id,0,0); return srcCanvas;
}

/* ===== Prompts ===== */
function bgPromptVariants(role){
  // вариативность сцен для каждого образа
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  if (role==="журналист") {
    const scenes = [
      "broadcast newsroom, glass anchor desk, cameras, boom mics, LED wall with abstract news graphics",
      "TV studio control room viewpoint, cameras on tripods, soft panels, diffuse reflections on floor",
      "press briefing room, podium out of frame, microphones and softboxes, newsroom glass walls"
    ];
    return pick(scenes) + ", shallow depth of field, photographic noise, correct perspective, no readable text";
  }
  if (role==="блогер") {
    const scenes = [
      "creator studio, ring light, softboxes, green screen, DSLR on tripod, shelves with props",
      "cozy streaming room, RGB ambient lights, desk with mic arm, softbox out of frame",
      "minimal studio with seamless green backdrop, ring light reflection on lens"
    ];
    return pick(scenes) + ", shallow depth of field, photographic noise, correct perspective, no readable text";
  }
  // фотограф
  const scenes = [
    "professional photo studio, backdrop rolls, C-stands, light stands, softboxes, cables on floor",
    "industrial loft studio, v-flats, large octabox, backdrop support system",
    "white cyclorama studio, apple boxes, sandbags, c-stands with flags"
  ];
  return scenes[Math.floor(Math.random()*scenes.length)] + ", slight lens falloff, photographic noise, correct perspective, no readable text";
}
function outfitPrompt(role){
  if (role==="журналист") return "update ONLY clothing to smart-casual journalist style: tailored blazer in neutral tones, optional lapel mic; keep the same person and identity; photorealistic";
  if (role==="блогер")    return "update ONLY clothing to stylish casual blogger style: hoodie or tee, relaxed trousers; keep the same person and identity; photorealistic";
  return "update ONLY clothing to practical photographer style: dark utility vest or jacket; keep the same person and identity; photorealistic";
}

/* ===== Build mattes & bbox ===== */
async function buildMattesAndBBox(dataUrl){
  await Promise.all([loadBP(), loadPose()]);
  const img=await loadImg(dataUrl); const w=img.width,h=img.height;

  const [person, parts, poses] = await Promise.all([
    bp.segmentPerson(img,{internalResolution:'medium',segmentationThreshold:0.7}),
    bp.segmentPersonParts(img,{internalResolution:'medium',segmentationThreshold:0.7}),
    poseModel.estimatePoses(img)
  ]);

  let minX=w, minY=h, maxX=0, maxY=0;
  const kp=(poses[0]?.keypoints||[]).filter(k=>k.score>0.3);
  for (const p of kp){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
  if (!isFinite(minX)||!kp.length){ minX=w*0.25; maxX=w*0.75; minY=h*0.1; maxY=h*0.95; }
  const padX=(maxX-minX)*0.18, padY=(maxY-minY)*0.10;
  minX=Math.max(0,minX-padX); maxX=Math.min(w,maxX+padX);
  minY=Math.max(0,minY-padY); maxY=Math.min(h,maxY+padY);
  const bbox={ x:minX, y:minY, w:(maxX-minX), h:(maxY-minY) };

  const HEAD=new Set([0,1]); const ARMS=new Set([2,3,4,5]);

  // base person matte
  const baseMask=document.createElement("canvas"); baseMask.width=w; baseMask.height=h;
  { const g=baseMask.getContext("2d"); const id=g.createImageData(w,h);
    for(let i=0;i<w*h;i++) id.data[i*4+3]=(person.data[i]===1)?255:0; g.putImageData(id,0,0); }
  // hull → union → close → dilate
  const hull = poseHullMask(w,h,kp);
  const union=document.createElement("canvas"); union.width=w; union.height=h;
  { const g=union.getContext("2d"); g.drawImage(baseMask,0,0); g.globalCompositeOperation="lighter"; g.drawImage(hull,0,0); g.globalCompositeOperation="source-over"; }
  const closed = closeMask(union, 8, 32);
  const closedDilated = closeMask(closed, 4, 8);
  const mattePersonCanvas=document.createElement("canvas"); mattePersonCanvas.width=w; mattePersonCanvas.height=h;
  mattePersonCanvas.getContext("2d").drawImage(closedDilated,0,0);

  // head+hands mask (с мостиком шеи)
  const hhMask=document.createElement("canvas"); hhMask.width=w; hhMask.height=h;
  {
    const g=hhMask.getContext("2d"); const id=g.createImageData(w,h);
    for(let i=0;i<w*h;i++){ const pid=parts.data[i]; const on = (HEAD.has(pid)||ARMS.has(pid))?255:0; id.data[i*4+3]=on; }
    g.putImageData(id,0,0);
    const b=document.createElement("canvas"); b.width=w;b.height=h; const gb=b.getContext("2d"); gb.filter="blur(6px)"; gb.drawImage(hhMask,0,0);
    hhMask.width=w; hhMask.height=h; hhMask.getContext("2d").drawImage(b,0,0);
    // шея (чтобы голова стыковалась к телу)
    const nx = Math.round(bbox.x + bbox.w * 0.48);
    const ny = Math.round(bbox.y + bbox.h * 0.35);
    const nw = Math.round(bbox.w * 0.04);
    const nh = Math.round(bbox.h * 0.10);
    const g2 = hhMask.getContext("2d"); g2.fillStyle = "rgba(255,255,255,0.95)"; g2.fillRect(nx, ny, nw, nh);
  }

  // слой головы/кистей (сохраняем в качество источника)
  const base=await loadImg(dataUrl);
  const headCanvas=document.createElement("canvas"); headCanvas.width=w; headCanvas.height=h;
  const gh=headCanvas.getContext("2d"); gh.drawImage(base,0,0,w,h);
  gh.globalCompositeOperation="destination-in"; gh.drawImage(hhMask,0,0); gh.globalCompositeOperation="source-over";
  const headHands_png_b64=headCanvas.toDataURL("image/png").split(",")[1];

  // маска корпуса = person − (head+hands)
  const bodyMaskCanvas=document.createElement("canvas"); bodyMaskCanvas.width=w; bodyMaskCanvas.height=h;
  { const g=bodyMaskCanvas.getContext("2d"); g.drawImage(mattePersonCanvas,0,0);
    g.globalCompositeOperation="destination-out"; g.drawImage(hhMask,0,0);
    g.globalCompositeOperation="source-over";
    const b=document.createElement("canvas"); b.width=w;b.height=h; const gb=b.getContext("2d"); gb.filter="blur(3px)"; gb.drawImage(bodyMaskCanvas,0,0);
    bodyMaskCanvas.width=w; bodyMaskCanvas.height=h; bodyMaskCanvas.getContext("2d").drawImage(b,0,0); }

  // широкая «резервная» маска
  const reserve=document.createElement("canvas"); reserve.width=w; reserve.height=h; const gr=reserve.getContext("2d");
  gr.fillStyle="#000"; gr.fillRect(0,0,w,h); gr.fillStyle="#fff";
  const r=Math.max(bbox.w,bbox.h)*0.16;
  gr.beginPath(); gr.moveTo(bbox.x+r,bbox.y);
  gr.arcTo(bbox.x+bbox.w,bbox.y,bbox.x+bbox.w,bbox.y+bbox.h,r);
  gr.arcTo(bbox.x+bbox.w,bbox.y+bbox.h,bbox.x,bbox.y+bbox.h,r);
  gr.arcTo(bbox.x,bbox.y+bbox.h,bbox.x,bbox.y,r);
  gr.arcTo(bbox.x,bbox.y,bbox.x+bbox.w,bbox.y,r); gr.closePath(); gr.fill();
  const reserveFeather=document.createElement("canvas"); reserveFeather.width=w; reserveFeather.height=h;
  const grf=reserveFeather.getContext("2d"); grf.filter="blur(10px)"; grf.drawImage(reserve,0,0);

  return {
    person_mask_b64: mattePersonCanvas.toDataURL("image/png").split(",")[1],
    headHands_png_b64,
    bodyOnly_mask_b64: bodyMaskCanvas.toDataURL("image/png").split(",")[1],
    reserve_mask_b64: reserveFeather.toDataURL("image/png").split(",")[1],
    bbox
  };
}

/* ===== Compose helpers ===== */
function subtractMasks(aCanvas, bCanvas){
  const w=aCanvas.width, h=aCanvas.height;
  const out=document.createElement("canvas"); out.width=w; out.height=h;
  const g=out.getContext("2d"); g.drawImage(aCanvas,0,0);
  g.globalCompositeOperation="destination-out"; g.drawImage(bCanvas,0,0);
  g.globalCompositeOperation="source-over";
  return out;
}
async function addContactShadow(baseUrl, bbox){
  const img=await loadImg(baseUrl);
  const c=document.createElement("canvas"); c.width=img.width; c.height=img.height;
  const g=c.getContext("2d"); g.drawImage(img,0,0);
  const cx=(bbox.x + bbox.w*0.5), cy=(bbox.y + bbox.h*0.98);
  const rx=bbox.w*0.45, ry=bbox.h*0.06;
  g.save(); g.filter="blur(6px)"; g.globalAlpha=0.28;
  g.beginPath(); g.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); g.fillStyle="#000"; g.fill();
  g.restore();
  return c.toDataURL("image/png");
}
async function composeLogoOver(imgDataUrl){
  const base = await loadImg(imgDataUrl);
  const logo = await loadImg("logo.png").catch(()=>null);
  if (!logo) return imgDataUrl;
  const w=base.width,h=base.height;
  const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
  g.drawImage(base,0,0,w,h);
  const logoW=Math.max(120,Math.round(w*0.16)); const scale=logoW/logo.width; const logoH=Math.round(logo.height*scale);
  const pad=Math.max(16,Math.round(Math.min(w,h)*0.02)); const x=w-logoW-pad; const y=h-logoH-pad;
  g.fillStyle="rgba(255,255,255,0.85)"; const br=Math.round(logoH*0.18);
  g.beginPath(); g.moveTo(x+br,y); g.arcTo(x+logoW,y,x+logoW,y+logoH,br); g.arcTo(x+logoW,y+logoH,x,y+logoH,br); g.arcTo(x,y+logoH,x,y,br); g.arcTo(x,y,x+logoW,y,br); g.closePath(); g.fill();
  g.drawImage(logo,x,y,logoW,logoH);
  return c.toDataURL("image/png");
}

/* ===== Main pipeline ===== */
async function generate(){
  if (!file) return;
  statusEl.innerText="Подготовка…"; resultBox.style.display="none"; download.style.display="none"; hideErr(); if (SHOW_LOGS) logsEl.style.display="none";

  try{
    let {w,h,dataUrl,b64} = await resizeFile(file);

   statusEl.innerText = "Шаг 1/6: анализ позы и сегментация…";

// 1) приводим фото к единому размеру
let { w, h, dataUrl, b64 } = await resizeFile(file);

// 2) строим маски уже по ресайзнутому кадру
const mats = await buildMattesAndBBox(dataUrl);

// Шаг 2/6: генерация фона…
statusEl.innerText = "Шаг 2/6: генерация фона…";

let fd = new FormData();
fd.append("mode", "gen-bg");
fd.append("width", String(w));
fd.append("height", String(h));
fd.append("num_steps", String(BG_STEPS));
fd.append("prompt", bgPromptVariants(role));

let r;
try {
  r = await fetchTO(`${API_BASE}/api/safe-edit`, {
    method: "POST",
    body: fd,
  }, 120000);
} catch (e) {
  return showErr("Не удалось обратиться к AI: " + (e.message || e));
}

// если воркер вернул ошибку (не 200) — пробуем прочитать текст/JSON
if (!r.ok) {
  let raw = "";
  try { raw = await r.text(); } catch {}
  let j;
  try { j = JSON.parse(raw); } catch { j = { raw }; }

  log({ stage: "gen-bg-error", status: r.status, resp: j });

  const msg =
    (j.error || "Не удалось создать фон") +
    (j.details ? "\n" + j.details : "");
  return showErr(msg);
}

// тут всё хорошо: ожидаем КАРТИНКУ от воркера
const ct = (r.headers.get("Content-Type") || "").toLowerCase();
if (!ct.startsWith("image/")) {
  const raw = await r.text().catch(() => "");
  log({ stage: "gen-bg-non-image", status: r.status, raw });
  return showErr("Сервер вернул неожиданный ответ (ожидалась картинка).");
}

// конвертируем blob → dataURL
const blob = await r.blob();
let bgUrl = await new Promise((resolve, reject) => {
  const fr = new FileReader();
  fr.onload = () => resolve(fr.result);     // data:image/png;base64,...
  fr.onerror = () => reject(fr.error || new Error("FileReader error"));
  fr.readAsDataURL(blob);
});

// Шаг 3/6: подчистка фона…
statusEl.innerText = "Шаг 3/6: подчистка фона…";

// теперь bgUrl — это dataURL
let fd2 = new FormData();
fd2.append("mode", "bg-inpaint");
fd2.append("image_b64", bgUrl.split(",")[1]);
fd2.append("mask_b64", mats.reserve_mask_b64);
fd2.append("prompt", "keep background consistent and clean space for a standing person; photorealistic; no text");

let r2 = await fetchTO(`${API_BASE}/api/safe-edit`, { method: "POST", body: fd2 }, 120000);
let text2 = await r2.text();
let j2;
try { j2 = JSON.parse(text2); } catch { j2 = { raw: text2 }; }

log({ stage: "bg-inpaint", status: r2.status, resp: j2 });

if (r2.ok && j2.imageBase64) {
  bgUrl = "data:image/png;base64," + j2.imageBase64;
}
    statusEl.innerText="Шаг 3/6: подчистка фона под человека…";
    fd=new FormData();
    fd.append("mode","bg-inpaint");
    fd.append("image_b64", bgUrl.split(",")[1]);
    fd.append("mask_b64", mats.reserve_mask_b64);
    fd.append("prompt", "keep background consistent and clean space for a standing person; photorealistic; no text");
    r=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fd }, 120000);
    j=JSON.parse(await r.text());
    if (r.ok && j.imageBase64) bgUrl = "data:image/png;base64,"+j.imageBase64;

    statusEl.innerText="Шаг 4/6: построение манекена…";
    const fullImg = await loadImg(dataUrl);
    const crop = cropSquareAroundBBox(fullImg, mats.bbox, 0.22, 512);
    const silhouette = document.createElement("canvas"); silhouette.width=512; silhouette.height=512;
    { const g=silhouette.getContext("2d");
      const src=await loadImg(crop.dataUrl); g.drawImage(src,0,0,512,512);
      const matte=await loadImg("data:image/png;base64,"+mats.person_mask_b64);
      const matteCrop = cropSquareAroundBBox(matte, mats.bbox, 0.22, 512);
      const mImg=await loadImg(matteCrop.dataUrl);
      g.globalAlpha=0.65; g.drawImage(mImg,0,0);
    }
    let fdBP=new FormData();
    fdBP.append("mode","body-proxy");
    fdBP.append("image_b64", silhouette.toDataURL("image/png").split(",")[1]);
    fdBP.append("prompt",
      role==="журналист"
        ? "upper body of a professional journalist wearing a tailored blazer and microphone pin, realistic proportions, neutral colors"
        : role==="блогер"
        ? "upper body of a trendy blogger in casual outfit, hoodie or denim jacket, realistic proportions"
        : "upper body of a photographer in dark functional outfit, camera strap, realistic proportions"
    );
    let rBP=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fdBP }, 120000);
    let jBP=JSON.parse(await rBP.text());
    let bodyProxy512 = jBP?.imageBase64 ? "data:image/png;base64,"+jBP.imageBase64 : crop.dataUrl;

    statusEl.innerText="Шаг 5/6: смена одежды…";
    const bodyMaskFull = await loadImg("data:image/png;base64,"+mats.bodyOnly_mask_b64);
    const bodyMaskCrop512 = cropSquareAroundBBox(bodyMaskFull, mats.bbox, 0.22, 512);
    const dilatedMask512 = await (async ()=>{
      const tmp=document.createElement("canvas"); tmp.width=512; tmp.height=512;
      tmp.getContext("2d").drawImage(await loadImg(bodyMaskCrop512.dataUrl),0,0);
      const grow = morph(tmp, 4, 48);  // мягче и точнее
      const blurC=document.createElement("canvas"); blurC.width=512; blurC.height=512;
      const gb=blurC.getContext("2d"); gb.filter="blur(6px)"; gb.drawImage(grow,0,0);
      return blurC.toDataURL("image/png");
    })();
    const fdW=new FormData();
    fdW.append("mode","wardrobe-mask");
    fdW.append("image_b64", bodyProxy512.split(",")[1]);
    fdW.append("mask_b64",  dilatedMask512.split(",")[1]);
    fdW.append("prompt", outfitPrompt(role));
    fdW.append("strength", String(CLOTH_STRENGTH));
    const rW=await fetchTO(`${API_BASE}/api/safe-edit`, { method:"POST", body:fdW }, 120000);
    const jW=JSON.parse(await rW.text());
    const outfit512=jW?.imageBase64 ? "data:image/png;base64,"+jW.imageBase64 : bodyProxy512;

    // вклейка 512→в полный размер (новый источник тела)
    const fullC=document.createElement("canvas"); fullC.width=fullImg.width; fullC.height=fullImg.height;
    const gfull=fullC.getContext("2d"); gfull.drawImage(fullImg,0,0);
    const o512=await loadImg(outfit512); const {x,y,side}=crop.rect; gfull.drawImage(o512, x,y,side,side);
    dataUrl=fullC.toDataURL("image/png"); b64=dataUrl.split(",")[1];

    /* ===== Шаг 6/6: сборка сцены (сохранение лица/кистей) ===== */
    const bg = await loadImg(bgUrl);
    const body = await loadImg(dataUrl);
    const headH = await loadImg("data:image/png;base64,"+mats.headHands_png_b64);
    const bodyMaskImg = await loadImg("data:image/png;base64,"+mats.bodyOnly_mask_b64);

    const comp = document.createElement("canvas"); comp.width = bg.width; comp.height = bg.height;
    const g = comp.getContext("2d");

    // центрирование: фон по cover, выравниваем по центру силуэта
    const targetCX = bg.width/2;
    const srcCX = mats.bbox.x + mats.bbox.w/2;
    const dx = Math.round(targetCX - srcCX);
    const pad = Math.abs(dx);
    const scale = 1 + (pad*2)/bg.width + 0.04;
    const sw = Math.round(bg.width * scale);
    const sh = Math.round(bg.height * scale);
    const ox = Math.round((sw - bg.width)/2) - dx;
    const oy = Math.round((sh - bg.height)/2);
    g.drawImage(bg, -ox, -oy, sw, sh);

    // корпус: ядро + размягчённый край
    const hm = document.createElement("canvas"); hm.width=bg.width; hm.height=bg.height; hm.getContext("2d").drawImage(bodyMaskImg,0,0);
    const core = morph(hm, 1.5, 128);     // ядро не «съедаем»
    const grow = morph(hm, 10, 12);
    const edge = subtractMasks(grow, core);
    const edgeBlur = document.createElement("canvas"); edgeBlur.width=bg.width; edgeBlur.height=bg.height;
    const geb=edgeBlur.getContext("2d"); geb.filter="blur(7px)"; geb.drawImage(edge,0,0);

    const finalAlpha = document.createElement("canvas"); finalAlpha.width=bg.width; finalAlpha.height=bg.height;
    const ga=finalAlpha.getContext("2d"); ga.drawImage(core,0,0); ga.globalCompositeOperation="lighter"; ga.drawImage(edgeBlur,0,0); ga.globalCompositeOperation="source-over";

    // fallback: если маска почти пустая — используем hm с лёгким blur
    (function ensureAlphaNotEmpty(){
      const gfa = finalAlpha.getContext("2d");
      const id = gfa.getImageData(0,0,finalAlpha.width,finalAlpha.height);
      let nz = 0; for (let i=3;i<id.data.length;i+=4){ if (id.data[i] > 12) { nz++; if (nz>5000) break; } }
      if (nz <= 5000){
        const safe = document.createElement("canvas"); safe.width=hm.width; safe.height=hm.height;
        const gs = safe.getContext("2d"); gs.filter="blur(2px)"; gs.drawImage(hm,0,0);
        gfa.clearRect(0,0,finalAlpha.width,finalAlpha.height); gfa.drawImage(safe,0,0);
      }
    })();

    // подготовка тела: цвет/резкость под фон
    const bodyAdj = document.createElement("canvas"); bodyAdj.width=body.width; bodyAdj.height=body.height;
    bodyAdj.getContext("2d").drawImage(body,0,0);

    const bgStats = statsRGB(comp, {
      x: Math.max(0, mats.bbox.x - 20),
      y: Math.max(0, mats.bbox.y - 20),
      w: mats.bbox.w + 40,
      h: mats.bbox.h + 40
    });
    matchColors(bodyAdj, bgStats);

    // лёгкий unsharp
    const sharp = document.createElement("canvas");
    sharp.width = bodyAdj.width; sharp.height = bodyAdj.height;
    const gsx = sharp.getContext("2d"); gsx.drawImage(bodyAdj,0,0);
    const blur = document.createElement("canvas");
    blur.width = bodyAdj.width; blur.height = bodyAdj.height;
    const gbx = blur.getContext("2d"); gbx.filter = "blur(2px)"; gbx.drawImage(bodyAdj,0,0);
    const idSrc = gsx.getImageData(0,0,sharp.width,sharp.height);
    const idBlur = gbx.getImageData(0,0,sharp.width,sharp.height);
    const d = idSrc.data, b = idBlur.data;
    for (let i=0;i<d.length;i+=4){
      d[i]   = Math.max(0, Math.min(255, d[i]*1.22 - b[i]*0.22));
      d[i+1] = Math.max(0, Math.min(255, d[i+1]*1.22 - b[i+1]*0.22));
      d[i+2] = Math.max(0, Math.min(255, d[i+2]*1.22 - b[i+2]*0.22));
    }
    gsx.putImageData(idSrc,0,0);
    bodyAdj.getContext("2d").drawImage(sharp,0,0);

    // мягкая гамма/контраст
    const gAdj = bodyAdj.getContext("2d");
    const iid = gAdj.getImageData(0,0,bodyAdj.width,bodyAdj.height);
    const p = iid.data;
    for (let i=0;i<p.length;i+=4){
      for (let c=0;c<3;c++){
        let v = p[i+c]/255;
        v = Math.pow(v, 0.96);
        v = (v-0.5)*1.05 + 0.5;
        p[i+c] = Math.max(0, Math.min(255, v*255));
      }
    }
    gAdj.putImageData(iid,0,0);

    // применяем альфу корпуса
    const bodySoft = document.createElement("canvas"); bodySoft.width=bg.width; bodySoft.height=bg.height;
    const gbod = bodySoft.getContext("2d"); gbod.drawImage(bodyAdj,0,0);
    gbod.globalCompositeOperation="destination-in"; gbod.drawImage(finalAlpha,0,0); gbod.globalCompositeOperation="source-over";
    g.drawImage(bodySoft, 0, 0);

    // ГОЛОВА И КИСТИ — ПОСЛЕДНИМИ, 1:1 ИСТОЧНИК (сохранение лица)
    const hh = await loadImg("data:image/png;base64,"+mats.headHands_png_b64);
    g.drawImage(hh, 0, 0);

    // тень + лого
    let outUrl = comp.toDataURL("image/png");
    outUrl = await addContactShadow(outUrl, mats.bbox);
    outUrl = await composeLogoOver(outUrl);

    resultImg.src=outUrl; resultBox.style.display="block"; download.href=outUrl; download.style.display="inline-block";
    statusEl.innerText="Готово ✓ · лицо сохранено, корпус без ореола, фон сгенерирован";
  }catch(e){
    showErr(e.message||"Неизвестная ошибка");
  }
}
</script>
</body>
</html>

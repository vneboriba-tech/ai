<script>
// === универсальный лоадер base64 (png/jpeg/webp) ===
async function loadB64ImageAny(b64){
  const types = ["image/png", "image/jpeg", "image/webp"];
  let err=null;
  for (const t of types){
    try{
      const url=`data:${t};base64,`+b64;
      const img=new Image(); img.crossOrigin="anonymous";
      await new Promise((res,rej)=>{img.onload=res;img.onerror=rej;img.src=url;});
      return img;
    }catch(e){err=e;}
  }
  throw err || new Error("Не удалось декодировать imageBase64");
}

// === чуть умнее расширяем бокс головы ===
function growBox(b, {padX=0.9, padY=1.3, biasY=0.04}={}){
  // padX/padY — во сколько раз расширяем от исходного, biasY — смещение вниз (к подбородку/шее)
  const cx = b.x + b.w/2;
  const cy = b.y + b.h/2 + biasY*b.h;
  let w = Math.min(1, b.w*padX);
  let h = Math.min(1, b.h*padY);
  let x = cx - w/2, y = cy - h/2;
  if (x < 0) x = 0; if (y < 0) y = 0;
  if (x + w > 1) x = 1 - w; if (y + h > 1) y = 1 - h;
  return { x, y, w, h };
}

// === маска: ЧЁРНОЕ = НЕ редактировать (голова), БЕЛОЕ = редактировать ===
async function buildHeadMaskB64(srcB64, bbox){
  const img = await loadB64ImageAny(srcB64); // универсальный лоадер
  const W=img.width, H=img.height;
  const c=document.createElement("canvas"); c.width=W; c.height=H;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#ffffff"; ctx.fillRect(0,0,W,H);

  // если детектор не дал бокс — возьмём безопасный «бюст»-бокс по центру
  let b = bbox || { x:0.23, y:0.14, w:0.54, h:0.66 };

  // адаптация к ракурсу: шире — для профиля; больше вниз — чтобы накрыть подбородок/шею
  const ar = b.w / (b.h || 1e-6);
  const padX = ar > 0.95 ? 1.9 : 2.2;   // профиль → шире
  const padY = ar > 1.10 ? 2.2 : 2.6;   // и чуть выше/ниже
  const big = growBox(b, { padX, padY, biasY: 0.06 });

  const x=Math.round(big.x*W), y=Math.round(big.y*H);
  const w=Math.round(big.w*W), h=Math.round(big.h*H);
  const cx = x + w/2, cy = y + h/2;

  // эллипс без поворота, но сильно расширенный — накрывает уши/лоб/подбородок
  ctx.save();
  ctx.beginPath();
  ctx.ellipse(cx, cy, w*0.50, h*0.60, 0, 0, Math.PI*2);
  ctx.clip();
  ctx.fillStyle="#000000";
  ctx.fillRect(x,y,w,h);
  ctx.restore();

  return c.toDataURL("image/png").split(",")[1] || "";
}

// === подмена в местах, где грузили base64 как PNG ===
async function composeLogoOnly(base64Gen){
  const gen = await loadB64ImageAny(base64Gen); // <-- заменили
  const W=gen.width, H=gen.height;
  const canvas=document.createElement("canvas"); canvas.width=W; canvas.height=H;
  const ctx=canvas.getContext("2d");
  ctx.drawImage(gen,0,0,W,H);
  try {
    const logo = await loadImage(LOGO_URL);
    const m = Math.round(Math.min(W,H)*0.02);
    const tw = Math.round(W * 0.14);
    const r  = (logo.width||1)/(logo.height||1);
    const th = Math.round(tw/r);
    const x = W - tw - m, y = H - th - m;
    ctx.globalAlpha = 0.95;
    const p = Math.round(tw*0.08);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillRect(x-p, y-p, tw+p*2, th+p*2);
    ctx.drawImage(logo, x, y, tw, th);
    ctx.globalAlpha = 1;
  } catch {}
  return canvas.toDataURL("image/png");
}

async function composeFaceAndLogo(base64Gen, base64Src, bbox){
  const genImg = await loadB64ImageAny(base64Gen); // <-- заменили
  const srcImg = await loadB64ImageAny(base64Src); // <-- заменили
  const W=genImg.width, H=genImg.height;

  const canvas=document.createElement("canvas"); canvas.width=W; canvas.height=H;
  const ctx=canvas.getContext("2d");
  ctx.drawImage(genImg, 0, 0, W, H);

  if (bbox){
    // та же расширенная область для «возврата» исходного лица
    const ar = bbox.w/(bbox.h||1e-6);
    const big = growBox(bbox, { padX: ar>0.95?1.8:2.0, padY: ar>1.1?2.0:2.3, biasY:0.05 });

    const sx=Math.round(big.x*srcImg.width);
    const sy=Math.round(big.y*srcImg.height);
    const sw=Math.round(big.w*srcImg.width);
    const sh=Math.round(big.h*srcImg.height);
    const dx=Math.round(big.x*W);
    const dy=Math.round(big.y*H);
    const dw=Math.round(big.w*W);
    const dh=Math.round(big.h*H);

    // мягкая маска (перо) для плавного перехода
    const mask=document.createElement("canvas"); mask.width=dw; mask.height=dh;
    const mctx=mask.getContext("2d");
    const R=Math.min(dw,dh);
    const g=mctx.createRadialGradient(dw/2, dh/2, R*0.34, dw/2, dh/2, R*0.52);
    g.addColorStop(0,"rgba(0,0,0,1)");
    g.addColorStop(1,"rgba(0,0,0,0)");
    mctx.fillStyle=g; mctx.fillRect(0,0,dw,dh);

    const face=document.createElement("canvas"); face.width=dw; face.height=dh;
    const fctx=face.getContext("2d"); fctx.drawImage(srcImg, sx, sy, sw, sh, 0, 0, dw, dh);

    ctx.save();
    ctx.drawImage(face, dx, dy, dw, dh);
    ctx.globalCompositeOperation='destination-in';
    ctx.drawImage(mask, dx, dy);
    ctx.restore();
  }

  try {
    const logo = await loadImage(LOGO_URL);
    const m = Math.round(Math.min(W,H)*0.02);
    const tw = Math.round(W * 0.14);
    const r  = (logo.width||1)/(logo.height||1);
    const th = Math.round(tw/r);
    const x = W - tw - m, y = H - th - m;
    ctx.globalAlpha = 0.95;
    const p = Math.round(tw*0.08);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillRect(x-p, y-p, tw+p*2, th+p*2);
    ctx.drawImage(logo, x, y, tw, th);
    ctx.globalAlpha = 1;
  } catch {}

  return canvas.toDataURL("image/png");
}
</script>

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Почувствуй себя журналистом</title>
  <meta name="description" content="Журналист / Блогер / Фотограф — реалистичная смена окружения с сохранением лица" />
  <style>
    :root { --bg:#ffffff; --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --accent:#2563eb; }
    * { box-sizing:border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Avenir Next",Segoe UI,Roboto,Helvetica,Arial;}
    body { display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { text-align:center; margin-top:24px; margin-bottom:16px; }
    h1 { font-size:clamp(28px,4vw,42px); margin:0; font-weight:800; }
    .container { width:100%; max-width:960px; padding:20px; }
    .uploader { border:2px dashed var(--border); border-radius:24px; padding:40px 20px; background:#f9fafb; text-align:center; cursor:pointer; transition:.2s; }
    .uploader:hover { border-color:var(--accent); background:#f0f9ff; }
    .uploader img.logo { width:72px; height:72px; margin-bottom:12px; }
    .headline { font-weight:700; font-size:18px; }
    .sub { color:var(--muted); font-size:14px; margin-top:6px; }
    .picked { margin-top:10px; font-size:14px; }
    .roles { margin-top:24px; }
    .roles-title { text-align:center; font-weight:700; font-size:18px; }
    .roles-grid { display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px; }
    @media(min-width:720px){ .roles-grid{grid-template-columns:repeat(3,1fr);} }
    .role { border:1px solid var(--border); border-radius:14px; padding:12px; font-weight:700; cursor:pointer; background:#fff; transition:.15s; }
    .role:hover { box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .role.active { border-color:var(--accent); box-shadow:0 0 0 3px rgba(37,99,235,0.2); }
    .status { margin-top:20px; text-align:center; font-size:15px; white-space:pre-wrap; }
    .err { color:#dc2626; font-size:14px; text-align:center; margin-top:10px; display:none; white-space:pre-wrap; }
    .result { margin-top:24px; text-align:center; }
    .result img { width:100%; max-width:800px; border-radius:18px; border:1px solid var(--border); }
    .btn { background:#10b981; color:#fff; padding:10px 16px; border-radius:12px; border:none; cursor:pointer; font-weight:700; }
    .btn:hover { background:#059669; }
    footer { margin-top:40px; text-align:center; color:#6b7280; font-size:14px; }
    pre#logs { text-align:left; background:#0b1020; color:#cbd5e1; padding:12px; border-radius:12px; overflow:auto; max-height:260px; font-size:12px; display:none; }
  </style>
  <!-- TF.js + BodyPix -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
</head>
<body>
  <div class="container">
    <header><h1>Почувствуй себя журналистом</h1></header>

    <div class="uploader" id="dropzone">
      <img src="logo.png" alt="Логотип" class="logo" onerror="this.style.display='none'">
      <div class="headline">Загрузите фото</div>
      <div class="sub">JPG, PNG, WEBP до 12 МБ</div>
      <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp" style="display:none" />
      <div id="picked" class="picked"></div>
    </div>

    <div class="roles">
      <div class="roles-title">Выберите роль</div>
      <div class="roles-grid">
        <button class="role active" data-role="журналист">Журналист</button>
        <button class="role" data-role="блогер">Блогер</button>
        <button class="role" data-role="фотограф">Фотограф</button>
      </div>
    </div>

    <div id="status" class="status">Готово к работе</div>
    <div id="error" class="err"></div>

    <div id="resultBox" class="result" style="display:none;">
      <img id="resultImg" alt="Результат">
      <div style="margin-top:12px;">
        <a id="download" class="btn" download="result.png" style="display:none;">Скачать PNG</a>
      </div>
    </div>

    <pre id="logs"></pre>
  </div>

  <footer>© 2025 факультет журналистики МГУ</footer>

<script>
const API_BASE = "https://media-gen-worker.vneboriba.workers.dev";
const MAX_MB = 12;
const MAX_SIZE = 1024;

let file = null;
let role = "журналист";
let bodyPixModel = null;
let lastOriginalDataUrl = null; // для оверлея

const input = document.getElementById("fileInput");
const drop = document.getElementById("dropzone");
const picked = document.getElementById("picked");
const statusEl = document.getElementById("status");
const err = document.getElementById("error");
const resultBox = document.getElementById("resultBox");
const resultImg = document.getElementById("resultImg");
const download = document.getElementById("download");
const logsEl = document.getElementById("logs");

function showErr(m){ err.style.display="block"; err.innerText=m; statusEl.innerText="Ошибка"; }
function hideErr(){ err.style.display="none"; err.innerText=""; }
function showLogs(obj){ try{ logsEl.style.display="block"; logsEl.textContent = typeof obj==="string"?obj:JSON.stringify(obj,null,2); }catch{} }
function fetchWithTimeout(url, init = {}, ms = 120000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), ms);
  return fetch(url, { ...init, signal: ctrl.signal }).finally(()=>clearTimeout(id));
}

drop.addEventListener("click", () => input.click());
drop.addEventListener("dragover", e => e.preventDefault());
drop.addEventListener("drop", e => { e.preventDefault(); const f = e.dataTransfer.files?.[0]; if (f) handleFile(f); });
input.addEventListener("change", e => handleFile(e.target.files?.[0]));

document.querySelectorAll(".role").forEach(b=>{
  b.addEventListener("click",()=>{
    document.querySelectorAll(".role").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    role=b.dataset.role;
    if (file) generateImage();
  });
});

function handleFile(f){
  if (!f) return;
  if (!f.type.startsWith("image/")) return showErr("Нужен файл изображения.");
  if (f.size > MAX_MB*1024*1024) return showErr("Слишком большой файл (до 12 МБ).");
  hideErr();
  file = f;
  picked.innerText = `Вы выбрали: ${f.name}`;
  generateImage();
}

async function loadBP(){
  if (bodyPixModel) return bodyPixModel;
  statusEl.innerText="Загрузка сегментации…";
  bodyPixModel = await bodyPix.load({ architecture:"MobileNetV1", outputStride:16, multiplier:0.75, quantBytes:2 });
  return bodyPixModel;
}

async function resizeFile(f){
  const dataUrl = await new Promise((res,rej)=>{
    const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f);
  });
  const img = await loadImage(dataUrl);
  let w = img.width, h = img.height;
  const k = Math.max(w,h)>MAX_SIZE ? MAX_SIZE/Math.max(w,h) : 1;
  w = Math.round(w*k); h = Math.round(h*k);
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  c.getContext("2d").drawImage(img,0,0,w,h);
  const dataUrlResized = c.toDataURL("image/jpeg",0.92);
  return { b64: dataUrlResized.split(",")[1], width:w, height:h, dataUrl: dataUrlResized };
}
function loadImage(src){
  return new Promise((res,rej)=>{
    const img=new Image(); img.crossOrigin="anonymous"; img.onload=()=>res(img); img.onerror=rej; img.src=src;
  });
}

/* маска головы для оверлея: face + hair + верхняя часть торса/плеч */
async function makeHeadMaskAndOverlay(dataUrl){
  const img = await loadImage(dataUrl);
  const model = await loadBP();

  // сегментация по частям
  const parts = await model.segmentPersonParts(img, { internalResolution:'medium', segmentationThreshold:0.7 });
  const w = img.width, h = img.height;
  const mask = new Uint8ClampedArray(w*h); // 0=прозрачн (не брать), 255=брать

  // набор частей: лицо (0), волосы (1) — в BodyPix могут отличаться, возьмём все head-пиксели
  const headPartIds = new Set([0,1]); // face, hair
  // добавим верх торса/плеч: partId 12..15 — левая/правая рука/плечо (зависит от модели)
  for (let i=0;i<parts.data.length;i++){
    const pid = parts.data[i];
    if (headPartIds.has(pid)) mask[i] = 255;
  }

  // добавим «воротник/верх плеч» вокруг головы: дилатация на 6–8 px
  const dilate = (field, w,h,rad) => {
    const out = new Uint8ClampedArray(field);
    const r = rad|0;
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        if (field[y*w+x]===255){
          for (let dy=-r; dy<=r; dy++){
            for (let dx=-r; dx<=r; dx++){
              const xx=x+dx, yy=y+dy;
              if (xx<0||yy<0||xx>=w||yy>=h) continue;
              out[yy*w+xx] = 255;
            }
          }
        }
      }
    }
    return out;
  };
  const field = dilate(mask, w,h,8);

  // собрать прозрачный PNG с мягким краем
  const c = document.createElement("canvas"); c.width=w; c.height=h;
  const g = c.getContext("2d");
  const base = await loadImage(dataUrl);
  g.drawImage(base,0,0,w,h);

  // делаем мягкую маску
  const m = document.createElement("canvas"); m.width=w; m.height=h;
  const gm = m.getContext("2d");
  const imgData = gm.createImageData(w,h);
  for (let i=0;i<w*h;i++){
    const v = field[i];
    imgData.data[i*4+0]=0; imgData.data[i*4+1]=0; imgData.data[i*4+2]=0; imgData.data[i*4+3]=v;
  }
  gm.putImageData(imgData,0,0);
  const blur = document.createElement("canvas"); blur.width=w; blur.height=h;
  const gb = blur.getContext("2d"); gb.filter="blur(6px)"; gb.drawImage(m,0,0);

  // применяем как маску (destination-in)
  const overlay = document.createElement("canvas"); overlay.width=w; overlay.height=h;
  const go = overlay.getContext("2d");
  go.drawImage(base,0,0,w,h);
  go.globalCompositeOperation="destination-in";
  go.drawImage(blur,0,0,w,h);
  go.globalCompositeOperation="source-over";

  return overlay.toDataURL("image/png").split(",")[1];
}

/* логотип-оверлей */
async function composeLogoOver(imgDataUrl){
  let baseImg, logoImg;
  try { baseImg = await loadImage(imgDataUrl); } catch { return imgDataUrl; }
  try { logoImg = await loadImage("logo.png"); } catch { return imgDataUrl; }
  const w = baseImg.width, h = baseImg.height;
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  const g=c.getContext("2d");
  g.drawImage(baseImg,0,0,w,h);
  const logoW = Math.max(120, Math.round(w*0.16));
  const scale = logoW / logoImg.width;
  const logoH = Math.round(logoImg.height * scale);
  const pad = Math.max(16, Math.round(Math.min(w,h)*0.02));
  const x = w - logoW - pad;
  const y = h - logoH - pad;
  g.fillStyle = "rgba(255,255,255,0.85)";
  const br = Math.round(logoH*0.18);
  g.beginPath();
  g.moveTo(x+br,y);
  g.arcTo(x+logoW,y,x+logoW,y+logoH,br);
  g.arcTo(x+logoW,y+logoH,x,y+logoH,br);
  g.arcTo(x,y+logoH,x,y,br);
  g.arcTo(x,y,x+logoW,y,br);
  g.closePath(); g.fill();
  g.drawImage(logoImg, x, y, logoW, logoH);
  return c.toDataURL("image/png");
}

/* промпты ролей — гендер-нейтральные */
function rolePrompt(role){
  if (role==="журналист")
    return "subtle wardrobe shift to smart-casual newsroom style; keep the same person and identity; photorealistic editorial look; no text, no watermark";
  if (role==="блогер")
    return "subtle wardrobe shift to trendy creator style; keep the same person and identity; photorealistic clean light; no text, no watermark";
  if (role==="фотограф")
    return "subtle wardrobe shift to practical photographer style; keep the same person and identity; photorealistic studio vibe; no text, no watermark";
  return "subtle wardrobe shift, keep identity unchanged; photorealistic; no text";
}

async function generateImage(){
  if (!file) return;
  statusEl.innerText="Подготовка…";
  resultBox.style.display="none"; download.style.display="none"; hideErr(); logsEl.style.display="none";

  try{
    const resized = await resizeFile(file);
    lastOriginalDataUrl = resized.dataUrl;

    // строим оверлей головы
    statusEl.innerText="Сохраняем лицо…";
    const headOverlayB64 = await makeHeadMaskAndOverlay(resized.dataUrl);

    // отправляем img2img
    statusEl.innerText="Генерация образа…";
    const fd = new FormData();
    fd.append("role", role);
    fd.append("image_b64", resized.b64);
    fd.append("prompt", rolePrompt(role));

    const r = await fetchWithTimeout(`${API_BASE}/api/safe-edit`, { method:"POST", body:fd }, 120000);
    const t = await r.text();
    let j = null; try { j = JSON.parse(t); } catch { showLogs(t); return showErr("Некорректный ответ сервера (ожидался JSON)."); }
    showLogs(j);

    if (!r.ok || !j.imageBase64) return showErr(j?.error ? `AI ошибка: ${j.error}${j.details?` — ${j.details}`:''}` : 'AI не прислал изображение.');

    // Композиция: сгенерённое -> поверх head overlay
    const genUrl = "data:image/png;base64," + j.imageBase64;
    const composed = await composeHeadOverlay(genUrl, "data:image/png;base64," + headOverlayB64);

    // Логотип сверху
    const finalUrl = await composeLogoOver(composed);

    resultImg.src = finalUrl;
    resultBox.style.display="block";
    download.href = finalUrl;
    download.style.display="inline-block";
    statusEl.innerText = `Готово ✓ · ${j.stage || j.modelUsed || 'Workers AI'}`;
  }catch(e){
    if (e.name === "AbortError") showErr("Превышено время ожидания ответа сервера.");
    else showErr(e.message || "Неизвестная ошибка сети");
  }
}

/* склеиваем head overlay + сгенерённый кадр */
async function composeHeadOverlay(genUrl, headOverlayUrl){
  const base = await loadImage(genUrl);
  const head = await loadImage(headOverlayUrl);
  const c=document.createElement("canvas"); c.width=base.width; c.height=base.height;
  const g=c.getContext("2d");
  g.drawImage(base,0,0,base.width,base.height);
  g.drawImage(head,0,0,base.width,base.height); // head PNG уже с прозрачностью
  return c.toDataURL("image/png");
}
</script>
</body>
</html>
